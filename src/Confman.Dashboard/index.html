<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Confman Cluster Dashboard</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 40px;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #fff;
        }
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 40px;
        }
        .cluster {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }
        .node {
            background: #16213e;
            border-radius: 16px;
            padding: 30px;
            width: 280px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .node:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.4);
        }
        .node-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }
        .status-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        .status-dot.ready { background: #00d26a; }
        .status-dot.not-ready { background: #ffc107; }
        .status-dot.offline { background: #ff4757; animation: none; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .node-name {
            font-size: 1.4em;
            font-weight: 600;
        }
        .node-url {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 20px;
            font-family: monospace;
        }
        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #2a2a4a;
        }
        .info-row:last-child {
            border-bottom: none;
        }
        .info-label {
            color: #888;
        }
        .info-value {
            font-weight: 500;
        }
        .role-leader {
            color: #00d26a;
            font-weight: 700;
        }
        .role-follower {
            color: #5dade2;
        }
        .role-unknown {
            color: #888;
        }
        .status-ready {
            color: #00d26a;
        }
        .status-not-ready {
            color: #ffc107;
        }
        .status-offline {
            color: #ff4757;
        }
        .section-title {
            text-align: center;
            color: #fff;
            margin: 40px 0 20px 0;
            font-size: 1.2em;
            font-weight: 500;
        }
        .configs-container {
            max-width: 900px;
            margin: 0 auto;
            background: #16213e;
            border-radius: 12px;
            overflow: hidden;
        }
        .config-header {
            display: grid;
            grid-template-columns: 1fr 1fr 150px;
            gap: 20px;
            padding: 12px 20px;
            background: #0f3460;
            font-weight: 600;
            color: #888;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .config-item {
            display: grid;
            grid-template-columns: 1fr 1fr 150px;
            gap: 20px;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid #2a2a4a;
        }
        .config-item:last-child {
            border-bottom: none;
        }
        .config-key {
            font-family: monospace;
            color: #5dade2;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .config-value {
            font-family: monospace;
            color: #00d26a;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .config-ns {
            color: #888;
            font-family: monospace;
            font-size: 0.9em;
            text-align: right;
        }
        .configs-empty {
            padding: 30px;
            text-align: center;
            color: #666;
        }
        .last-update {
            text-align: center;
            color: #666;
            margin-top: 40px;
            font-size: 0.9em;
        }
        .cluster-summary {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #16213e;
            border-radius: 12px;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }
        .cluster-summary .summary-status {
            font-size: 1.5em;
            font-weight: 700;
            margin-bottom: 10px;
        }
        .cluster-summary .summary-status.healthy { color: #00d26a; }
        .cluster-summary .summary-status.degraded { color: #ffc107; }
        .cluster-summary .summary-status.down { color: #ff4757; }
        .cluster-summary .summary-details {
            color: #888;
            font-size: 0.95em;
        }
        .controls {
            text-align: center;
            margin-bottom: 30px;
        }
        .controls button {
            background: #0f3460;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            margin: 0 5px;
        }
        .controls button:hover {
            background: #1a4a7a;
        }
        .controls button.active {
            background: #00d26a;
        }
    </style>
</head>
<body>
    <h1>Confman Cluster</h1>
    <p class="subtitle">Raft Consensus Dashboard</p>

    <div class="cluster-summary" id="clusterSummary"></div>

    <div class="controls">
        <button onclick="refresh()">Refresh Now</button>
        <button id="autoRefreshBtn" class="active" onclick="toggleAutoRefresh()">Auto-refresh: ON</button>
        <a id="swaggerLink" href="#" target="_blank" style="display: none;">
            <button>API Docs (Swagger)</button>
        </a>
    </div>

    <div class="cluster" id="cluster"></div>

    <h2 class="section-title">Namespaces</h2>
    <div class="configs-container" id="namespaces"></div>

    <h2 class="section-title">Stored Configurations</h2>
    <div class="configs-container" id="configs"></div>

    <p class="last-update">Last update: <span id="lastUpdate">-</span></p>

    <script>
        const nodes = [
            { name: 'Node 1', url: 'http://127.0.0.1:6100' },
            { name: 'Node 2', url: 'http://127.0.0.1:6200' },
            { name: 'Node 3', url: 'http://127.0.0.1:6300' }
        ];

        let autoRefresh = true;
        let refreshInterval;

        function formatTime(date) {
            return date.toLocaleTimeString();
        }

        async function fetchNodeStatus(node) {
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 2000);

                const response = await fetch(`${node.url}/health/ready`, {
                    signal: controller.signal
                });
                clearTimeout(timeout);

                // Parse JSON even for 503 (not_ready) responses
                const data = await response.json();
                return { ...data, reachable: true };
            } catch (e) {
                // Network error or timeout - node is truly offline
                return { reachable: false };
            }
        }

        function renderNode(node, data) {
            const isOffline = !data.reachable;
            const status = isOffline ? 'offline' : data.status;
            const role = isOffline ? 'unknown' : data.cluster?.role || 'unknown';
            const term = isOffline ? '-' : data.cluster?.term ?? '-';
            const leader = isOffline ? '-' : data.cluster?.leader || '-';
            const leaderKnown = isOffline ? false : data.cluster?.leaderKnown;

            const statusClass = isOffline ? 'offline' : (status === 'ready' ? 'ready' : 'not-ready');
            const roleClass = role === 'leader' ? 'role-leader' : (role === 'follower' ? 'role-follower' : 'role-unknown');
            const statusText = isOffline ? 'OFFLINE' : (status === 'ready' ? 'READY' : 'NO QUORUM');

            return `
                <div class="node">
                    <div class="node-header">
                        <div class="status-dot ${statusClass}"></div>
                        <span class="node-name">${node.name}</span>
                    </div>
                    <div class="node-url">${node.url}</div>
                    <div class="info-row">
                        <span class="info-label">Status</span>
                        <span class="info-value status-${statusClass}">${statusText}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Role</span>
                        <span class="info-value ${roleClass}">${role.toUpperCase()}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Epoch</span>
                        <span class="info-value">${term}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Leader</span>
                        <span class="info-value" style="font-size: 0.85em">${leaderKnown ? leader : 'Unknown'}</span>
                    </div>
                </div>
            `;
        }

        async function fetchConfigs(results) {
            // Try to fetch from a healthy node (prefer leader)
            const healthyNodes = results
                .map((r, i) => ({ ...r, url: nodes[i].url }))
                .filter(r => r.reachable && r.status === 'ready');

            if (healthyNodes.length === 0) {
                return [];
            }

            // Prefer leader
            const targetNode = healthyNodes.find(n => n.cluster?.role === 'leader') || healthyNodes[0];

            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 3000);

                const response = await fetch(`${targetNode.url}/api/v1/configs`, {
                    signal: controller.signal
                });
                clearTimeout(timeout);

                if (!response.ok) return [];
                return await response.json();
            } catch (e) {
                return [];
            }
        }

        function renderConfigs(configs) {
            if (configs.length === 0) {
                return '<div class="configs-empty">No configurations stored</div>';
            }

            const header = `
                <div class="config-header">
                    <span>Key</span>
                    <span>Value</span>
                    <span style="text-align: right">Namespace</span>
                </div>
            `;

            const rows = configs.map(c => `
                <div class="config-item">
                    <div class="config-key" title="${c.key}">${c.key}</div>
                    <div class="config-value" title="${c.value}">${c.value}</div>
                    <div class="config-ns">${c.ns}</div>
                </div>
            `).join('');

            return header + rows;
        }

        async function fetchNamespaces(results) {
            // Try to fetch from a healthy node (prefer leader)
            const healthyNodes = results
                .map((r, i) => ({ ...r, url: nodes[i].url }))
                .filter(r => r.reachable && r.status === 'ready');

            if (healthyNodes.length === 0) {
                return [];
            }

            // Prefer leader
            const targetNode = healthyNodes.find(n => n.cluster?.role === 'leader') || healthyNodes[0];

            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 3000);

                const response = await fetch(`${targetNode.url}/api/v1/namespaces`, {
                    headers: { 'X-Api-Key': 'confman_dev_abc123' },
                    signal: controller.signal
                });
                clearTimeout(timeout);

                if (!response.ok) return [];
                return await response.json();
            } catch (e) {
                return [];
            }
        }

        function renderNamespaces(namespaces) {
            if (namespaces.length === 0) {
                return '<div class="configs-empty">No namespaces created</div>';
            }

            const header = `
                <div class="config-header">
                    <span>Path</span>
                    <span>Description</span>
                    <span style="text-align: right">Owner</span>
                </div>
            `;

            const rows = namespaces.map(ns => `
                <div class="config-item">
                    <div class="config-key" title="${ns.path}">${ns.path}</div>
                    <div class="config-value" title="${ns.description || ''}">${ns.description || '-'}</div>
                    <div class="config-ns">${ns.owner}</div>
                </div>
            `).join('');

            return header + rows;
        }

        function renderClusterSummary(results) {
            const online = results.filter(r => r.reachable).length;
            const ready = results.filter(r => r.reachable && r.status === 'ready').length;
            const leader = results.find(r => r.reachable && r.cluster?.role === 'leader');
            const hasQuorum = online >= 2; // For 3-node cluster

            let statusClass, statusText;
            if (ready === nodes.length) {
                statusClass = 'healthy';
                statusText = 'HEALTHY';
            } else if (hasQuorum && leader) {
                statusClass = 'degraded';
                statusText = 'DEGRADED';
            } else {
                statusClass = 'down';
                statusText = 'NO QUORUM';
            }

            const leaderInfo = leader ? leader.cluster.leader : 'None';

            return `
                <div class="summary-status ${statusClass}">${statusText}</div>
                <div class="summary-details">
                    ${online}/${nodes.length} nodes online &bull;
                    Leader: ${leaderInfo}
                </div>
            `;
        }

        async function refresh() {
            const results = await Promise.all(nodes.map(node => fetchNodeStatus(node)));

            document.getElementById('clusterSummary').innerHTML = renderClusterSummary(results);
            const html = nodes.map((node, i) => renderNode(node, results[i])).join('');
            document.getElementById('cluster').innerHTML = html;

            // Fetch and display namespaces
            const namespaces = await fetchNamespaces(results);
            document.getElementById('namespaces').innerHTML = renderNamespaces(namespaces);

            // Fetch and display stored configs
            const configs = await fetchConfigs(results);
            document.getElementById('configs').innerHTML = renderConfigs(configs);

            // Update Swagger link (prefer leader, fallback to any reachable node)
            const swaggerLink = document.getElementById('swaggerLink');
            const leaderNode = results.find((r, i) => r.reachable && r.cluster?.role === 'leader');
            const anyNode = results.find((r, i) => r.reachable);

            if (leaderNode || anyNode) {
                const targetIdx = leaderNode
                    ? results.indexOf(leaderNode)
                    : results.indexOf(anyNode);
                swaggerLink.href = `${nodes[targetIdx].url}/swagger`;
                swaggerLink.style.display = 'inline-block';
            } else {
                swaggerLink.style.display = 'none';
            }

            document.getElementById('lastUpdate').textContent = formatTime(new Date());
        }

        function toggleAutoRefresh() {
            autoRefresh = !autoRefresh;
            const btn = document.getElementById('autoRefreshBtn');
            btn.textContent = `Auto-refresh: ${autoRefresh ? 'ON' : 'OFF'}`;
            btn.classList.toggle('active', autoRefresh);

            if (autoRefresh) {
                refreshInterval = setInterval(refresh, 2000);
            } else {
                clearInterval(refreshInterval);
            }
        }

        // Initial load
        refresh();
        refreshInterval = setInterval(refresh, 2000);
    </script>
</body>
</html>
